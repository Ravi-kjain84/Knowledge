Yes, you can apply formatting while using ws.append() in openpyxl by directly setting the styles and properties of the worksheet cells.

Hereâ€™s how you can apply the following types of formatting:
	1.	Increase the width of a column â€“ Set ws.column_dimensions
	2.	Merge columns in a row â€“ Use ws.merge_cells()
	3.	Wrap text within a cell â€“ Use Alignment(wrap_text=True)

Updated Example Based on Your Code

Hereâ€™s an example incorporating these changes:

from openpyxl import Workbook
from openpyxl.styles import Font, Alignment, PatternFill

# Sample test evidence
test_evidence = {
    'Test_001': {
        'Test Case Information': {'ID': '001', 'Description': 'Sample Test Case'},
        'SQL Logic': {'Query': 'SELECT * FROM table WHERE value > 100;'},
        'SQL Output': {'Result': 'Success'},
        'Null Check': {'Status': 'Passed'}
    }
}

wb = Workbook()

for test_case_id, evidence in test_evidence.items():
    ws = wb.create_sheet(title=str(test_case_id))
    
    # Set column width
    ws.column_dimensions['A'].width = 25
    ws.column_dimensions['B'].width = 50
    
    if "Test Case Information" in evidence:
        # Add header and format it
        ws.append(["Test Case Information"])
        header_cell = ws.cell(row=ws.max_row, column=1)
        header_cell.font = Font(bold=True, color="FFFFFF")
        header_cell.fill = PatternFill("solid", fgColor="4F81BD")
        
        # Merge 5 columns and center align the text
        ws.merge_cells(start_row=ws.max_row, start_column=1, end_row=ws.max_row, end_column=5)
        header_cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)

        for key, value in evidence["Test Case Information"].items():
            ws.append([key, value])
            
        ws.append([])  # Empty row

    if "SQL Logic" in evidence:
        ws.append(["SQL Logic"])
        header_cell = ws.cell(row=ws.max_row, column=1)
        header_cell.font = Font(bold=True, color="FFFFFF")
        header_cell.fill = PatternFill("solid", fgColor="4F81BD")
        
        # Merge cells for SQL Logic header
        ws.merge_cells(start_row=ws.max_row, start_column=1, end_row=ws.max_row, end_column=5)
        header_cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)

        for key, value in evidence["SQL Logic"].items():
            ws.append([key, value])
        
        ws.append([])

    if "SQL Output" in evidence:
        ws.append(["SQL Output"])
        header_cell = ws.cell(row=ws.max_row, column=1)
        header_cell.font = Font(bold=True, color="FFFFFF")
        header_cell.fill = PatternFill("solid", fgColor="4F81BD")
        ws.merge_cells(start_row=ws.max_row, start_column=1, end_row=ws.max_row, end_column=5)
        header_cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)

        for key, value in evidence["SQL Output"].items():
            ws.append([key, value])
        
        ws.append([])

    if "Null Check" in evidence:
        ws.append(["Null Check"])
        header_cell = ws.cell(row=ws.max_row, column=1)
        header_cell.font = Font(bold=True, color="FFFFFF")
        header_cell.fill = PatternFill("solid", fgColor="4F81BD")
        ws.merge_cells(start_row=ws.max_row, start_column=1, end_row=ws.max_row, end_column=5)
        header_cell.alignment = Alignment(horizontal="center", vertical="center", wrap_text=True)

        for key, value in evidence["Null Check"].items():
            ws.append([key, value])
        
        ws.append([])

# Save the workbook
wb.save("test_evidence.xlsx")



â¸»

âœ… Changes and Fixes:
	1.	Increased column width:
	â€¢	ws.column_dimensions['A'].width = 25
	2.	Merged cells for headers:
	â€¢	ws.merge_cells(start_row=ws.max_row, start_column=1, end_row=ws.max_row, end_column=5)
	3.	Set alignment and wrap text:
	â€¢	Alignment(horizontal="center", vertical="center", wrap_text=True)
	4.	Header Formatting:
	â€¢	Bold header text and background color using Font and PatternFill.

â¸»

ðŸš€ Outcome:
	â€¢	The headers are now bold, centered, and highlighted.
	â€¢	Column widths are adjusted for better visibility.
	â€¢	Merged cells are used where needed.
	â€¢	Text wrapping ensures no overflow issues.

Let me know if youâ€™d like to tweak any more details!






def compare_dataframes(df1, df2):
    """Compare structure and data of two DataFrames with NULL and EMPTY handling."""

    # Standardize column names (remove spaces, convert to lowercase)
    df1.columns = df1.columns.str.strip().str.lower()
    df2.columns = df2.columns.str.strip().str.lower()

    # Convert all values to strings to prevent type mismatches
    df1 = df1.astype(str)
    df2 = df2.astype(str)

    # Handle NULL, NONE, and empty values by converting them to a common placeholder ("NA")
    df1 = df1.replace(["None", "NULL", "nan", "NaN", ""], "NA")
    df2 = df2.replace(["None", "NULL", "nan", "NaN", ""], "NA")

    # Remove leading/trailing spaces
    df1 = df1.applymap(lambda x: x.strip() if isinstance(x, str) else x)
    df2 = df2.applymap(lambda x: x.strip() if isinstance(x, str) else x)

    # Convert text to lowercase for case-insensitive comparison
    df1 = df1.applymap(lambda x: x.lower() if isinstance(x, str) else x)
    df2 = df2.applymap(lambda x: x.lower() if isinstance(x, str) else x)

    # Round floating-point values to avoid precision issues
    df1 = df1.apply(pd.to_numeric, errors='ignore').round(4)
    df2 = df2.apply(pd.to_numeric, errors='ignore').round(4)

    # Convert date columns to a standardized format
    for col in df1.columns:
        if df1[col].dtype == "datetime64[ns]":
            df1[col] = pd.to_datetime(df1[col])
            df2[col] = pd.to_datetime(df2[col])

    # Compare Column Structure
    cols1, cols2 = set(df1.columns), set(df2.columns)
    missing_cols_df1, missing_cols_df2 = list(cols2 - cols1), list(cols1 - cols2)

    # Compare Row Data
    matching_rows = pd.merge(df1, df2, how="inner")
    missing_rows_df1 = pd.merge(df2, df1, how="left", indicator=True).query('_merge == "left_only"').drop("_merge", axis=1)
    missing_rows_df2 = pd.merge(df1, df2, how="left", indicator=True).query('_merge == "left_only"').drop("_merge", axis=1)

    return missing_cols_df1, missing_cols_df2, missing_rows_df1, missing_rows_df2, matching_rows